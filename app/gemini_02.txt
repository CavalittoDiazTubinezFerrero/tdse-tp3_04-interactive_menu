### Análisis y Explicación del Código Fuente

El código proporcionado corresponde a una aplicación para un microcontrolador STM32 que implementa un planificador simple basado en eventos de tiempo (tick de sistema) para ejecutar un conjunto de tareas cooperativas. El sistema gestiona la lectura de botones y una interfaz de menú interactiva en un display LCD, e incluye una biblioteca de logging para depuración.

---

#### **`app.c` - Núcleo de la Aplicación y Planificador**

* **Función**: Este archivo es el corazón de la aplicación y actúa como un planificador cooperativo muy simple.
* **`app_init()`**: Se ejecuta una sola vez al inicio. Su responsabilidad es inicializar todas las tareas del sistema (en este caso, `task_sensor` y `task_menu`), configurar los contadores globales y preparar el hardware para medir tiempos de ejecución. Durante esta fase, utiliza `LOGGER_INFO()` extensivamente para imprimir mensajes de estado.
* **`app_update()`**: Se llama continuamente desde el bucle infinito de `main.c`. Comprueba si ha ocurrido un "tick" del sistema (es decir, si la variable `g_app_tick_cnt` es mayor que cero). Si es así, ejecuta la función `update` de cada tarea registrada en secuencia.
* **Medición de Tiempo**: Dentro de `app_update()`, mide el tiempo de ejecución de cada tarea en microsegundos después de que esta se completa. Utiliza esta medición para actualizar dos variables clave:
    * `g_app_runtime_us`: El tiempo total de ejecución de todas las tareas en un ciclo.
    * `task_dta_list[index].WCET`: El "Tiempo de Ejecución en el Peor Caso" (Worst-Case Execution Time) para cada tarea individual, guardando el valor más alto medido hasta el momento.
* **`HAL_SYSTICK_Callback()`**: Es la función que se ejecuta cada vez que ocurre la interrupción del `SysTick` (típicamente cada 1 ms). Su único propósito es incrementar los contadores `g_app_tick_cnt`, `g_task_sensor_tick_cnt` y `g_task_menu_tick_cnt`, que actúan como "banderas" o eventos de tiempo para que `app_update` y las tareas sepan que deben ejecutar su lógica.

---

#### **`task_sensor.c` - Tarea de Lectura de Botones**

* **Función**: Define la lógica para leer el estado de tres botones, implementando un mecanismo de anti-rebote (debouncing) para asegurar lecturas estables.
* **`task_sensor_init()`**: Se ejecuta una vez desde `app_init()`. Usa `LOGGER_INFO()` para imprimir sus propios mensajes de inicialización.
* **`task_sensor_update()`**: Se ejecuta periódicamente desde `app_update()`. Llama a `task_sensor_statechart()`, que contiene la lógica principal.
* **`task_sensor_statechart()`**: Contiene una máquina de estados para cada botón que gestiona el anti-rebote. Cuando detecta una pulsación o liberación válida (después de un retardo `tick_max`), no actúa directamente. En su lugar, **produce un evento** (ej. `EV_MEN_ENT_ACTIVE`) y lo coloca en una cola de eventos usando `put_event_task_menu()`. Este diseño desacopla la detección del hardware de la lógica de la aplicación.

---

#### **`task_menu.c` - Tarea de la Interfaz de Usuario**

* **Función**: Gestiona la lógica del menú interactivo que se muestra en el display LCD. Es una tarea **consumidora de eventos**.
* **`task_menu_init()`**: Se ejecuta una vez. Llama a `LOGGER_INFO()`, inicializa la cola de eventos y configura el display LCD con un mensaje de bienvenida.
* **`task_menu_update()`**: Se ejecuta periódicamente. Llama a `task_menu_statechart()`.
* **`task_menu_statechart()`**: Contiene la máquina de estados del menú. Primero, comprueba si hay eventos pendientes en la cola generada por `task_sensor`. Si hay un evento, lo procesa para cambiar el estado del menú (por ejemplo, de inactivo a activo). Además, en el estado activo, actualiza un contador en la pantalla periódicamente basándose en su propio temporizador.

---

#### **`logger.c` y `logger.h` - Biblioteca de Logging**

* **Función**: Proporciona una forma de enviar mensajes de texto desde el microcontrolador a un computador para depuración, usando una técnica llamada semihosting.
* **`LOGGER_INFO()`**: Es una macro que simplifica el uso del logger. Su funcionamiento es crítico para entender el comportamiento del sistema.
* **Mecanismo de Funcionamiento y Consecuencias**:
    1.  **Deshabilita Interrupciones**: Lo primero que hace es ejecutar `__asm("CPSID i");`, lo que **detiene todas las interrupciones del sistema**, incluido el `SysTick` que marca el paso del tiempo.
    2.  **Formatea y Envía el Mensaje**: Llama a `snprintf` y luego a `logger_log_print_`, que a su vez usa `printf`. El `printf` vía semihosting es una operación **extremadamente lenta**, ya que detiene la ejecución del microcontrolador para comunicarse con el depurador en la PC.
    3.  **Habilita Interrupciones**: Al finalizar, ejecuta `__asm("CPSIE i");` para reactivar las interrupciones.

---

### ### Impacto de `LOGGER_INFO()` en la Evolución de las Variables

El uso de `LOGGER_INFO()` tiene un impacto muy diferente dependiendo de si se usa en la fase de inicialización o en el bucle principal. En este código, **solo se usa en la fase de inicialización**.

**Nota**: La consulta menciona `g_task_test_tick_cnt`. En el código proporcionado no existe tal variable, sino `g_task_sensor_tick_cnt` y `g_task_menu_tick_cnt`. El análisis se centrará en estas últimas, ya que son las que existen y son afectadas.

#### **Durante la Fase de Inicio (`app_init`)**

En esta fase, `app_init()`, `task_sensor_init()` y `task_menu_init()` llaman a `LOGGER_INFO()` varias veces.

* **`g_app_runtime_us` (unidad: microsegundos)**
    * **Impacto Nulo**. Esta variable solo se mide y actualiza dentro del bucle de `app_update()`. Como `app_init()` se ejecuta completamente antes de que el bucle principal comience, todo el tiempo consumido por el logger durante el arranque **no se mide ni se almacena** en `g_app_runtime_us`. Su valor sigue siendo el inicial (0) hasta la primera ejecución de `app_update`.

* **`task_dta_list[index].WCET` (unidad: microsegundos)**
    * **Impacto Nulo**. Al igual que `g_app_runtime_us`, el `WCET` se inicializa a 0 en `app_init()` y solo se actualiza en `app_update()`. Por lo tanto, el uso intensivo del logger durante el arranque no afecta su valor inicial.

* **`g_task_sensor_tick_cnt` y `g_task_menu_tick_cnt` (unidad: milisegundos / ticks)**
    * **Impacto Significativo y Crítico**. Aunque `LOGGER_INFO()` deshabilita las interrupciones *durante* su ejecución, estas se reactivan brevemente entre una llamada a `LOGGER_INFO` y la siguiente. Como el logging por semihosting es muy lento, pueden pasar muchos milisegundos (o incluso segundos) mientras se imprimen todos los mensajes de inicio. Durante los intervalos en que las interrupciones están habilitadas, la interrupción del `SysTick` seguirá ocurriendo en segundo plano.
    * **Evolución**: `HAL_SYSTICK_Callback()` se ejecutará múltiples veces mientras `app_init()` está "atascado" imprimiendo logs. Como resultado, cuando `app_init()` finalmente termina y cede el control al primer ciclo de `app_update()`, los contadores como `g_task_sensor_tick_cnt` y `g_task_menu_tick_cnt` **ya tendrán un valor acumulado considerable**, correspondiente a la cantidad de milisegundos que transcurrieron durante la lenta fase de inicialización.

#### **Durante la Ejecución del Bucle Principal (`app_update`)**

Al analizar `task_sensor.c` y `task_menu.c`, se observa que sus funciones de actualización (`task_sensor_update` y `task_menu_update`) **no contienen ninguna llamada a `LOGGER_INFO()`**. Por lo tanto:

* **`g_app_runtime_us` (unidad: microsegundos)**
    * **Sin Impacto Directo**. Dado que el logger no se llama, esta variable medirá únicamente el tiempo de ejecución real de la lógica de las tareas (`task_sensor_update` y `task_menu_update`). Su valor reflejará el rendimiento de las tareas en sí, no la sobrecarga del logger.

* **`task_dta_list[index].WCET` (unidad: microsegundos)**
    * **Sin Impacto Directo**. Al igual que con `g_app_runtime_us`, el `WCET` almacenará el tiempo máximo de ejecución de la lógica de cada tarea, sin la interferencia del logger.

* **`g_task_sensor_tick_cnt` y `g_task_menu_tick_cnt` (unidad: milisegundos / ticks)**
    * **Sin Impacto Directo**. Las variables seguirán su ciclo normal: serán incrementadas cada milisegundo por la interrupción del `SysTick` y decrementadas por sus respectivas tareas al ser procesadas. La ausencia de llamadas al logger en el bucle principal asegura que no haya pausas inesperadas que impidan que las tareas procesen los ticks a tiempo.

**Conclusión clave**: El `LOGGER_INFO()` introduce un retardo bloqueante muy grande, pero en este código, su impacto se limita a la fase de arranque. Esto retrasa el inicio de la operación normal y causa que los contadores de tick ya tengan un valor acumulado al empezar. Durante la operación normal del bucle principal, no tiene influencia en las métricas de tiempo de ejecución.